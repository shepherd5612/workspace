# 6.7 -数据结构

## 线性结构

分类：

- 顺序表/数组（Vector / Array）
- 链表（Linked List）
- 队列（Queue）
- 栈（Stack）



特点：

- 唯一前趋
- 唯一后继
- 第一个元素只有一个后继
- 最后一个元素只有一个前趋

## 非线性结构

分类：

- 二维数组、多维数组
- 树
- 图



结构

- 层次结构
- 群结构



特点：

- 每个元素可与0个或多个元素发生联系。



# 6.8-顺序表/数组

## 一般形式：

typedef struct Vector {

int size, length;

int *data;

}

## 顺序表结构体内的变量定义：

- size：即为顺序表所开内存空间大小
- length：顺序表元素数量/长度。0时表示没有元素。
- *data：指针变量，指向顺序表/数组的第一个元素地址，通过索引的方式找到顺序表其他元素。

## 操作函数：

- init（Vector *vector，int size）
- expand（Vector *vector）：一般顺序表内存空间满时，扩展为原内存空间的2倍。
- insert（Vector *vector，int index，int element）：插入的位置索引，插入的元素。
- search（Vector *vector，int element）：在顺序表中查找某元素，返回int值或返回索引值。
- delete_node（Vector *vector，int index，int element）：**注意删除某元素后，原最后一位元素的情况**。



# 7.19-P1

## 1、基础数据结构简介

数据结构要解决的问题：大规模数据如何组织（在内存中）？怎么操作？

main函数中变量数据存在栈端，数据量较小。全局变量数据量较大。两者差别？

gdb调试：

```
int *b[][4]
一维数组、二维数组、指针
数组名是数组的首地址，是常量
```

内存相关操作：

- 动态申请空间：malloc calloc（会初始化为0）

  局部变量都在stack中，而stack最大空间8M。若想用更大内存空间，需要借内存，从heap（堆）中借一部分内存，通过指针接这个内存，访问堆，就用这个指针p。

  所以大数据都需要在堆中处理

  .data段，.bss段：程序编译时

  stack、heap：程序运行时才会需要

- 栈空间

- 静态数据区域



做题平台：

- 海贼OJ
- 牛客网
- leetcode
- 浙大PTA：ACM竞赛题



# 7.20-数据结构

## 数据结构总览

- 数据结构定义

  数据+结构，是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合。

  - 数据及组织方式：连续线性、非连续线性、树状等
  - 数据的操作算法：增删改查

- 逻辑结构和物理结构

  - 物理结构：内存中存储关系
  - 逻辑结构：相互之间顺序关系

- 数据结构目录

- 算法的时间复杂度

- 算法的空间复杂度

## 1、线性表

- 问题来源：数组存在与栈中，在系统中被限制了大小。因此要在堆段中操作管理动态数组。

- 定义：是具有相同数据类型的n个数据元素的有限序列。

- 物理存储结构：用一段地址连续的存储单元依次存储线性表。

- 管理节点：第一个数在哪里（a[0]）？总共几个数（length）？已经有多少个数？

- 构造、初始化及释放

  下图的解释：

  - 第一部分：堆中动态申请Vector结构体，用于构造动态数组，包含三个参数：length长度、size大小、*data指针指向数组
  - 第二部分：*data指针指向的数组，是在堆中真实存储数组数据的结构
  - 第三部分：stack中定义的Vector变量v，调用堆中的Vector数据

  free时同样先释放掉*data，然后再释放掉Vector v。

  ![1- 线性表构造和释放结构图](D:\BaiduNetdiskWorkspace\VScode\C++_kaikeba\笔记\数据结构图片\1- 线性表构造和释放结构图.png)

- 插入操作

  注意图形化的插入原理，以此为基础写代码。

  ```
  if (!v) return 0;//为什么v为空时，不能插入？
  
  //新知识点：在插入时方法1是for循环，调整原插入位置及以后的的数据；方法2是用memcpy拷贝
  memcpy(*dst, *src, size_t)
  memcpy(v->data + index + 1, v->data + index, sizeof(int) * (v->len - index))
  ```

  

- 删除操作

- 扩容

  ```
  重新申请空间并赋值：
  方法1：int *temp
  方法2：realloc
  
  语法：realloc(*ptr, size_t)
  重新为ptr申请内存空间。
  （1）如果ptr为NULL，相当于重新malloc了size大小的内存空间；
  （2）如果size_t = 0，ptr为NULL，相当于free(*ptr)了；
  
  malloc，free，calloc，realloc等的用法。
  ```

  

## 2、链表

问题来源：线性存储结构在进行插入和删除操作时，需要找到大量的连续内存空间，并且需要移动大量元素，浪费资源。所以需要链式存储结构。

- 定义

  是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的数据结构。

- 管理节点（参数）

  第一个数据位置，总共有多少数据

- 插入

  ```
  两个结构体：
  struct Node
  
  struct Linkedlist
  
  当第0个位置为NULL时，虚拟头结点可以解决这个问题
  Node *p = &(L->head) //&取地址取到第一个元素的地址，并赋值给指针p，使p指向head，即可以将p理解为虚拟头结点。
  另一种思路就是判断语句，先判断0的位置，然后再判断后面的位置。
  ```

  虚拟头结点：-1的下标位置

  链表翻转的方法

  - 头插法
  - 本身转化法

- 删除

- 链表的反转

- 双向链表

- 循环链表




## 3、栈stack

- 定义

  栈是仅在表尾进行压入和弹出元素的线性表。本质是个线性表

  FILO：先进后出

- 结构

  

- 初始化、插入

## 4、队列



判断空队还是满队：技术总结

- head一直为空，tail指向最后一个放了数的位置。（或者head指向第一个数，tail指向最后一个数的下一个空位）
- 取模翻转：push时取模翻转
- 如果(q->tail+1) % q->size = q->head了，则判断为满队；如果q->tail == q->head则为空队。



队列两种结构思路：（两种方法代码实现）

- head指向空，tail指向最后一个有值的位置
- head指向第一个有值的位置，tail指向最后一个有值位置的下一个位置



## 5、树

一对多的问题

### 树的概念：

- 节点
  - 根节点：root
  - 叶节点/终端节点
  - 非终端节点
  - 父节点与子节点
  - 兄弟节点
  - 祖先
- 分支度：兄弟姐妹有多少
- 阶层，高度或深度：几代人
- 树林：好几家人



### 二叉树的概念：

二叉树是一种特殊的数。每个节点最多只有两个子节点。

- 节点

  - 左子树
  - 右子树

- 分支度：<= 2

- 特殊二叉树

  - 满二叉树：所有叶节点均在同一阶层，且除叶节点外每个节点均有两个子节点
  - 完全二叉树：除掉最大阶层后为满二叉树，且最大阶层节点均向左靠齐
  - 左歪斜树：所有节点，只有左子树，没有右子树
  - 右歪斜树：所有节点，只有右子树，没有左子树

- 二叉树的性质

  - 性质1：第i阶层最大节点数：2^(i - 1)

  - 性质2：深度为k的，最多有2^k - 1个节点。 =（2^0 + 2^1 +2^2 ... + 2^(k-1)

  - 性质3：终端节点个数为n0，度数为2的节点个数为n2，则n0 = n2 + 1。

    计算方法：n0为度数为0的节点（叶节点），n1为度数为1的节点，n2为度数为2的节点，则总的线的数量为（n0 + n1 + n2 -1）（减掉root节点）

    另外，一个n2阶段有两根线，一个n1节点有一根线，一个n0节点有零根线，因此（n0 * 0 + n1 * 1 + n2 * 2） =  （n0 + n1 + n2 - 1），即得到n0 = n2 + 1。

    概念：分支度数为2的节点，分支度数为1的节点，分支度数为0的节点（叶节点）

### 二叉树的遍历

遍历方式：

- 前序遍历：根左右
- 中序遍历：左根右，遍历完输出为有序数
- 后序遍历：左右根



树的广义表：

- 将树输出为广义表的形式。

- 根据广义表，转化为树。
  - 遇到数字就建立节点n，如果栈非空则将n插入栈顶节点的flag边
  - 左括号（：把刚建立的节点压栈，作为后续操作的root；flag=left
  - 右括号）：出栈
  - 逗号，：flag = right



线索二叉树：Threaded  Binary Tree



用数组实现完全二叉树：

第i层数据：左2×i+1，右2×i+2，为数组下标



堆heap（类似数组）

- heap的结构、定义、初始化、释放

  - 大顶堆

  - 小顶堆

- heap的弹出

- 优先队列：尾部压入，头部弹出，类似队列Queue，只不过入队后需要根据优先级进行

  ```
  
  ```

  调整，所以叫优先队列

  普通队列：	（最大/最小）堆

  尾部入队			尾部可以插入
  
  头部出队			头部可以弹出
  
  先进先出			每次出队权值（最大/最小的元素）
  
  数组实现			数组实现，逻辑上看成一个堆



## 6、排序

- 插入排序/冒泡排序：O（n2）

  - 插入排序：

    ```
    
    ```

  - 冒泡排序：

    ```
    
    ```

    

- 归并排序，merge_sort：O（nlogn），递归的思想

- 选择排序

- 快速排序



## 7、查找和哈希表

### 二分查找

#### （1）框架

- 一般情况

  ```c
  int l=0，r=n-1
  while(l <= r) {	//注意此处的<=号
      int mid = (l + r) >> 1;	//为防止mid越界，可改为mid = l + (r - l) >> 1
      if (arr[mid] == val) return mid;
      arr[mid] < val ? (l = mid + 1):(r = mid - 1);
  }
  return -1;	//出while循环后还没有返回值，则表示没有找到，返回-1。
  ```

- 特殊情况一：//00000001111111，左边一堆0，右边一堆1，查找第一个1。

  ```c
  //相当于查找满足某一条件的值中最小的一个值，或者可以理解为找某一类值的左边界。
  //第一种情况：当全部是0时，会出现返回n-1位置的情况，此时查找错误。
  int l = 0, r = n - 1;
  while (l < r) {
  	int mid = l + (r - l) >> 1;
  	if (arr[mid] == val) {
  		r = mid;	//注意此处：当mid处值等于要查找值时，说明待查找值在mid或mid左边
  	} else {
  		l = mid + 1;
  	}
  }
  return l;	//此时l == r，返回哪个都行。
  ```

  ```c
  //第二种情况（优化）：
  int l = 0, r = n;	//注意点1：右边界范围变化
  while (l < r) {
  	int mid = l + (r - l) >> 1;
  	if (arr[mid] == val) {
  		r = mid;	//注意点2：查找左边界，所以r不断先左移动。
  	} else {
  		l = mid + 1;
  	}
  }
  return l == n ? (-1) : l;
  ```

  注意：当全部都是0，没有1时，由于r=n-1，所以最终返回的索引为n-1，而实际n-1下标的元素为0，因此发生错误。此时应将二分查找范围设为l=0，r=n。

- 特殊情况二：//11111110000000，左边一堆1，右边一堆0，查找最后一个1。

  ```c
  
  int l = 0, r = n - 1;	//注意点1：若全部数据都是0时，只能找到l=0处，此时返回下标0，发生错误。所以l=-1，l应该从-1找起。
  while (l < r) {
      mid = (l + r + 1) / 2;	//注意点2：mid这样取值，会导致mid总是偏向l侧取值，当仅剩两个值时，导致mid始终等于l，无法找到r的位置，所以还应该+1。
      if (arr[mid] == val) {
          l = mid;	//注意点3：寻找右边界，所以l不断向右找。
      } else {
          r = mid - 1;
      }
  }
  return l == -1 ? (-1) : l;
  ```

#### （2）典型应用场景

- 单调矩阵：

- 求一个非负数的平方根：

- 梯度下降



### 哈希

#### （1）定义

待查值

- 哈希表结构、初始化、free：


```
//第一层：HashTable *h：指向哈希表的指针h。数据结构中两种元素，一是int size，表示链表长度；二是Node ** data，表示存储链表头节点指针的数组。

//第二层：哈希表的存储链表指针的数组，（Node *）*data，data即为存储链表头结点指针的数组

//第三层：每个链表，Node *head，指向链表

//第四层：链表中的每个节点Node *n。char *str存储字符串/数字元素，struct Node *next指向下一个节点。
```

![image-20210907183857821](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210907183857821.png)

- 哈希表的插入：插入char *str。

```
//第一步：将str放入Node结构体中，完成待插入节点的初始化，initNode(str);

//第二步：通过BKD哈希算法，将str字符串转化为hash值和哈希表索引值idx；

//第三步：将Node插入到哈希表数组中索引为idx的链表
```

- 查找：char *str

```
//第一步：通过BKD算法将str转化为hash索引，找到对应的链表；

//第二步：在链表中查找该str。
```



#### （2）哈希算法

- 数字哈希：
  - 直接法
  - 减去法
  - 取余法：哈希碰撞问题
  - 平方法
  - 随机数法

- 字符串哈希：

- 哈希碰撞的解决方法：牺牲空间，解决时间问题。
  - 线性开放寻址、二次方探索法、差值探索等
  - 链表解决法



string.h

函数：strdup()





## 8、测试宏





