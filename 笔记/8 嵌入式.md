# 总体架构和思路

### 1、嵌入式组成和架构：

架构：硬件层-中间层-软件层，每一层的组成、作用和技术

- 硬件层：芯片内部+外设（裸机）
- 中间层：对硬件的抽象，



### 2、单片机（嵌入式微控制器）

#### 裸机范畴：

芯片内部：

- 原理和体系结构：芯片内核如Cortex-M，ARM架构，存储器结构
- 接口原理和技术：接口有哪些，解决什么问题
- 接口应用开发：API（是否是BSP开发，比如usart、IIC，解决硬件的抽象问题，为软件开发提供接口？）



外设：

- 嵌入式终端系统开发：利用接口做模块发开
  - 传感器驱动：
  - 键盘
  - OLED

#### 操作系统范畴：

嵌入式实时操作系统：RTOS



嵌入式linux系统开发：



### 3、多个单片机（物联网）

#### 物联网架构



#### 硬件通讯接口协议和软件协议





#### 有线连接

串行

- SPI、IIC、UART
- 485/422，modbus，网络通信协议栈
- CAN，USB
- 以太网（TCP/IP精简协议）



#### 无线连接

传统无线通信：

- 红外：技术成熟

  - 编解码（发送模块和接收模块）；

  - 全方位/万能红外（360°红外接收和发射）；

  - 人体红外模块，寻迹模块

- 射频（RFID、NFC）

- GPS：北斗模块

**短距离无线通信（局域网）：**2.4GHz频段

- WIFI
- BT
- zigbee

远距离无线通信（广域网）：

- 移动通信，NB-IOT
- Lora





#### 物联网中间件

通信协议栈等，协议和数据包等



#### 物联网通信架构



# 芯片、内核、架构

STM32

Cortex-M

ARM

MCU：存储器结构（冯诺依曼架构、哈弗架构）；指令结构（复杂指令集、精简指令集）



## 嵌入式系统架构设计框图





|                 |                                       |          |
| --------------- | ------------------------------------- | -------- |
| 外部 通信       |                                       |          |
| 协议栈/通信协议 | TCP/IP、modbus；物联网通信协议MTQQ    |          |
| RTOS内核层      | FreeRTOS、ucos                        | 驱动框架 |
| 设备驱动        | 感知模块、执行模块、通信模块          | 驱动框架 |
| 接口驱动        | GPIO、UART、IIC、SPI、ADC、DAC、TIMER | 驱动框架 |
| 芯片            | STM32                                 |          |
| 内核            | Cortex-M                              |          |





## Systick timer

时钟源：AHB -> AHB/8时钟 -> Cortex system timer：系统时钟固定为AHB时钟的八分之一

寄存器配置：

- CTRL寄存器：CountFlag位、CLKSource位、ENABLE位
- LOAD寄存器：重装载寄存器，24位，保存计数值
- VAL寄存器：当前计数值



注意：LOAD的最大值为0xffffff，因此根据时钟源的频率，





# 裸机系统与多任务系统



|            | 事件响应 | 事件处理 | 特点                       |
| ---------- | -------- | -------- | -------------------------- |
| 轮询系统   | 主程序   | 主程序   | 轮询响应事件、轮询处理事件 |
| 前后台系统 | 中断     | 主程序   | 中断响应事件、轮询处理事件 |
| 多任务系统 | 中断     | 任务     | 实时响应事件、实时处理任务 |





# STM32裸机



## 开发模式及快速上手步骤

第二节：单片机开发模式介绍（黄老师）：

https://blog.csdn.net/weixin_48021291/article/details/123034884



## 整体结构框图

在datasheet中



## 寄存器映射表

查看寄存器映射表，用于寄存器编程。



## RCC



时钟树







## GPIO

### 0、几个问题：

- 设置为上拉还是下拉，与中断捕获上升沿和下降沿有关系吗？
- 片上外设什么时候需要配置复用？比如uart、iic、adc等？



### 1、基础

定义：General Purpose Input Output，通用输入输出接口。

作用：是可控制的引脚，可以通过其与外部硬件设备连接，实现外部通讯、采集外部硬件数据、控制外部硬件等功能。

分类：A-G7组，A-I9组等不同数量的组，每组16个

- GPIOA：PA0、PA1......PA15
- GPIOB：PB0、PB1......PB15等

基本结构（电路结构）：

- IO硬件口：接点
- 保护二极管：
- 输入线路：
  - 上拉电路
  - 下拉电路
  - TTL肖特基触发器
  - 通用读电路：输入数据寄存器
  - 复用功能输入：至片上外设
  - 模拟输入：至片上外设
- 输出线路：
  - 通用写电路：输出数据寄存器
  - 复用功能输出：来自片上外设
  - 输出控制
  - P-MOS和N-MOS：决定推挽、开漏或关闭



### 2、8种输入输出模式

#### （1）输入

输入：IPU，上拉输入，初始状态为高电平

输入：IPD，下拉输入，初始状态为低电平



|          | 信号通道                                                     | IO端口悬空状态（无信号输入） | IO端口输入低电平信号 | IO端口输入高电平信号 | 应用                                  |
| -------- | ------------------------------------------------------------ | ---------------------------- | -------------------- | -------------------- | ------------------------------------- |
| 上拉输入 | IO端口的电平信号直接进入输入数据寄存器                       | 初始化被上拉电阻拉高为高电平 | 端口变为低电平       |                      |                                       |
| 下拉输入 | IO端口的电平信号直接进入输入数据寄存器                       | 初始化被下拉电阻拉低为低电平 |                      | 端口变为高电平       |                                       |
| 浮空输入 | IO端口的电平信号直接进入输入数据寄存器                       | 电平不确定                   | 变为低电平           | 变为高电平           | 可以用于KEY检测，RX、TX、IIC、usart等 |
| 模拟输入 | IO端口的模拟信号（电压信号）直接模拟输入到片上外设模块，比如ADC模块等 |                              |                      |                      | ADC输入                               |



#### （2）输出

推挽输出（OUT_PP，push-pull）：两个参数相同的三极管或MOS管分别受两路互补信号的控制，总是在一个三极管或MOS管导通时，另一个截止。高低电平由输出电平决定。

- 输出0时，N-MOS导通，P-MOS高阻；
- 输出1时，N-MOS高阻，P-MOS导通（不需要外部上拉电路）。



开漏输出（OUT_OD，open-drain）：只可以输出强低电平，高电平由外部上拉电路决定。适合做电流型的驱动。

- 输出0时，N-MOS导通，P-MOS不被激活；
- 输出1时，N-MOS高阻，P-MOS不被激活，输出1（需要外部上拉电路）。



差异：

- 开漏是：输出0的时候直接接GND，输出1的时候是浮空。输出端相当于三极管的集电极，要得到高电平需要上拉电阻才行，适合做电流型的驱动，其吸收电流的能力相对强（一般20ma以内）。
- 推挽是：输出0的时候直接接GND，输出1的时候接VCC。可以直接输出高、低电平，连接数字器件。



|          | 信号通道                                                     | 输出低电平                                            | 输出高电平                                            | 其他特点                                                     | 应用                               |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 开漏     | CPU直接写输出数据寄存器->输出控制电路->**（N-MOS/上拉电路）**->IO端口 | 此时N-MOS管开启，直接通过N-MOS管输出低电平            | 此时N-MOS管关闭，由上拉电路提供的高电平提供输出高电平 | 输出时，此时IO端口的电平也可以通过输入电路读取。（注意：IO口读取的电平不一定是输出的电平） | 需要外接上拉电阻才能实现输出高电平 |
| 开漏复用 | 片上外设模块的复用功能输出->输出控制电路->（N-MOS/上拉电路）->IO端口 | 与开漏同                                              | 与开漏同                                              | 与开漏同                                                     | TX1、MOSI、MISO、SCK、SS           |
| 推挽     | CPU直接写输出数据寄存器->输出控制电路->**（N-MOS/P-MOS）**->IO端口 | P-MOS管关闭，N-MOS管开启，IO端口的低电平由N-MOS管决定 | P-MOS管开启，N-MOS管关闭，IO端口的高电平由P-MOS管决定 | IO端口的电平可以通过输入电路读取，并且读取的电平一定是输出的电平 | 可以输出高、低电平，广泛应用       |
| 推挽复用 | 片上外设模块的复用功能输出->输出控制电路->**（N-MOS/P-MOS）**->IO端口 | 与推挽同                                              | 与推挽同                                              | 与推挽同                                                     | IIC                                |



### 3、延伸扩展

保护二极管：

- 单向导通，用于防止外部引脚过高、过低的电压输入。

- 接Vdd端：当外部电压高于Vdd时导通，起到降压作用；
- 接Vss端：当外部电压低于Vss时导通，起到增压作用。



P-MOS管和N-MOS管：



TTL肖特触发器：

- 信号经过该触发器后，模拟信号转化为0和1的数字信号。
- 适用于浮空输入、上拉输入和下拉输入等输入模式。
- 当模拟输入时，不经过该触发器进行电平转化，直接到片上外设的模拟输入模块。























## TIM

本质是定时器的几类：核心计算是（装载值 / 频率）

- 基本定时器：16位
- 看门狗：12位
- Systick系统内核定时器：24位，精度最高



### 基本定时器

#### 作用

定时，比如uart定时发送、adc定时采集数据、测量脉宽信号、pwm输出等

特点：无外部引脚。（高级和通用定时器有外部引脚，可实现更多功能）



#### 主要寄存器

- ARR：auto reload register，自动重装载寄存器，16位。写入一个数值，当cnt的计数值达到此值后，cnt计数器重新开始计数。
- PSC：prescaler，预分频器，16位。
  - 时钟源：时钟的分频，时钟来源是（CK_INT，internal clock，内部时钟源）。
  - 时钟源的配置：通过RCC专用时钟配置寄存器（RCC_DCKCFGR）的TIMPRE位设置所有定时器的时钟频率。此位置为0时，如果APBx的psc为1，则TIMx_CLK = PCLKx；否则TIMx_CLK = 2 * PCLKx。
- CNT：计数器



影子寄存器：ARR寄存器自带影子寄存器，在硬件结构上实际是有两个寄存器

- 源寄存器我们可以进行读写操作，而影子寄存器我们无法操作，由内部硬件使用。
- 影子寄存器是在程序运行时真正起到作用的，只有在特定时候（特定时间发生时）才把源寄存器的值拷贝给它的影子寄存器。



#### 配置过程

基本定时器只需要配置两个参数：计数模式只有向上计数，不需要配置。

- psc配置：
- arr配置：



#### 疑难点

- 定时器psc分频的目的：为了使不同频率的时钟基本定时时，可选配置的ARR计数的选择更多，避免无法配置ARR
- 定时器“旋涡”：当定时器中断1us时，程序会陷入不断的中断中，无法跳出中断，导致无法实现中断定时。当设10us为最小精度时，能保证跳出中断
- 定时器的全局变量计数：设为extern类型，可在全局使用计数定时



### 高级定时器







#### 输入捕获

脉冲宽度检测

输入频率检测

按键时长检测



#### 输出比较

##### PWM应用

PWM调节占空比，实现灯亮度调整

- Pulse Width Modulation，脉宽调制

- 关键内容：占空比 = 通电时间/不通电时间（一个周期内）

- PWM等效电压：u = （t1 * U） / （t1 + t2），u为等效电压，U是PWM的电压幅值，t1是接通时间，t2是关断时间，t1+t2是周期T。t1大即占空比大，则等效电压就大。

- 同时要控制周期不能太大，否则t1和t2实际时间就过长，就会出现一闪一闪的现象。



关键步骤：

- GPIO配置：IO口时钟和AF时钟；结构体；GPIO的remap。
- 时基单元初始化：注意是arr变量决定后续占空比（？？？）。结构体；使能。
- 输出比较pwm初始化：oc结构体；使能；重装载。
- 配置oc值，改变占空比，得到pwm输出





## IWDG和WWDG

### 基本概念

本质：一种特殊的定时器。来自系统内部时钟。

作用：

- 用看门狗来监测程序是否出现问题，保证程序平稳运行。
- 每次主函数正常运行时会给看门狗定期喂食。若有特殊情况导致主函数不能正常运行，则主函数没有能力给看门狗喂食，此时看门狗就会发出Reset（复位）信号，让整个主函数能够继续正常运行。



### IWDG独立看门狗

时钟：

- 系统内LSI低频时钟源，大小为40KHz（一般在30kHz-60kHz之间，并非精确的40kHz）。
- 时钟独立，即使主时钟发生故障，它仍能有效。一旦开启，则只能由MCU复位后才能清除，让它不再工作。



寄存器：

- KR（Key Register）：通过写入此寄存器特定的值，设置prescaler和reload等权限
  - 0X5555：写入后，可开启写PR和RLR寄存器权限，设定prescaler和reload值。
  - 0XCCCC：写入后，可开启看门狗。
  - 0XAAAA：重新计数（喂食看门狗）。
- PR：3位，设置prescaler值
- RLR：12位，设置reload计数值



配置过程：

- 初始化：
  - KR寄存器写入0X5555，开启写PR和RLR寄存器权限
  - PR寄存器写入prescaler值
  - RLR寄存器写入reload值
  - KR寄存器写入0XAAAA，重新装载计数值
  - KR寄存器写入0XCCCC，开启看门狗
- 应用：在程序中调用函数，在KR寄存器写入0XAAAA，重新装载计数值，不断喂食。



应用：

- 不要使用硬件时钟中断喂狗，因为硬件时钟中断一般有较高优先级且独立于主程序，导致有时主程序跑飞，而仍能正常喂狗。
- 





### WWDG窗口看门狗

时钟：



### 两者比较



|          | IWDG                 | WWDG       |
| -------- | -------------------- | ---------- |
| 时钟源   | LSI，40kHz，时钟独立 | APB1时钟源 |
| 复位精度 |                      | 精度高     |
|          |                      |            |





## ADC模拟信号

作用：采集电压数字量信号（模拟量信号）



寄存器：





配置过程

- 





应用：

- 采集蓄电池电压信号
- 





## 中断







## USART

### 1、定义

- Universal Synchronous Asynchronous Receiver Transmitter，通用同步异步收发器
- full-duplex，全双工数据交换
- oversampling，过采样，8倍和16倍过采样
- 



### 2、配置过程

- 硬件接口配置：gpio配置
  - rx：
  - tx：
- 时钟开启
- usart配置：结构体配置
  - Baud波特率：根据给定的值，计算整数部分和小数部分
  - 
- usart使能：开启usart的使用
- 中断配置
  - nvic中断配置
  - 中断服务函数编写
- 发送、接收数据的函数编写



### 3、主要寄存器

| 寄存器            | 主要的位                      | 内容                                                         |
| ----------------- | ----------------------------- | ------------------------------------------------------------ |
| SR：状态寄存器    | TXE：Transmit Data Reg Empty  | （1）TDR中的内容发送至shift reg（移位寄存器）后，该位被置1。（2）产生中断，TXEIE位被置1。（3）用于发送单字符 |
|                   | TC：Transmission complete     | （1）一帧数据发送完成，且TXE被置1后，该位被置1。（2）产生中断，TCIE被置1。（3）用于发送一帧frame/多个字节的数据 |
|                   | RXNE：Read data reg Not Empty | （1）移位寄存器将数据发送给RDR后，该位被置1，说明接收到数据，CPU可以读此数据了。（2）产生中断，RXNEIE被置1。 |
| DR：数据寄存器    | DR[8:0]                       | 8位或9位，用于存放要发送的或要接收的数据。最高有效位由是否有校验决定 |
| BRR：波特率寄存器 | Div_Mantissa和Div_Fraction，  | 设置波特率整数和小数部分                                     |
| CR1：控制寄存器1  | UE：usart enable              | usart使能，即usart_cmd函数实现的功能，设置此位               |
|                   | M位                           | 设置WordLength                                               |
|                   | TXEIE、TCIE、RXNEIE           | 设置各类中断                                                 |
|                   | TE和RE                        | 发送和接收使能                                               |
| CR2：             | STOP位                        | 停止位的设置                                                 |
| CR3：             |                               |                                                              |
| GTPR：            |                               | Guard time and prescaler reg                                 |



### usart初始化结构体：

| 结构体成员          | 设置功能       | 对应寄存器           | 描述                                           |
| ------------------- | -------------- | -------------------- | ---------------------------------------------- |
| baud                | 波特率         | BRR（Baud Rate Reg） | 设置Div_Mantissa和Div_Fraction，整数和小数部分 |
| WordLength          | 字长           | CR1：M位             |                                                |
| StopBits            | 停止位         | CR2：stop位          |                                                |
| Parity              | 校验位         | CR1：PCE位           | 校验控制使能                                   |
| Mode                | 模式（Rx和Tx） | CR1：RE和TE位        | 发送使能和接收使能                             |
| HardwareFlowControl | 硬件流控制     |                      |                                                |



### 中断的几种情况：

目前主要用到TXE、TC、NXNE三个中断

| 中断类型 | 含义                                                        |      |
| -------- | ----------------------------------------------------------- | ---- |
| TXE      | 发送单个字节，发送完成，有TDR发送到shift reg后产生          |      |
| TC       | 发送数据帧/多个字节，多个字节数据发送完成，且TXE被置1后产生 |      |
| RXNE     | 接收非空，即数据从shift reg发送到RDR后产生                  |      |



### 疑难点

几个发送数据函数对比：

特别注意传参len的函数，可以发送‘\0’字符。

```c
//发送一个字节
void USART1_Send_Byte(u8 Data)
{
	USART_GetFlagStatus(USART1, 	USART_FLAG_TC);
	USART_SendData(USART1,Data);
	while( USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET );
}

//发送字符串，遇到字符串结尾标志'\0'结束
void USART1_Send_String(u8 *Data)
{
	while(*Data)
		USART1_Send_Byte(*Data++);
}

//按长度发送字符串，这种方法可以发送含0x00的字符串
void USART1_Send_String_By_Lens(u8 *Data, int Len)
{
	int i;
	for(i=0; i<len;i++)
	{
		USART_SendData(USART1, Data[i]);
		while(USART_GetFlagStatus(USART1, USART_FLAG_TC)==RESET); //串口1发送数据
	}
}
```



**怎么理解下面的接收函数？？？？？？**

0x0D：表示ACSII码中的回车，即\r

0x0A：表示ACSII码中的换行，即\n

通过判断末尾是否有回车、换行，从而判断是否输入完成。

状态机思想：取16位的数做标记，标记是否接收完成。

- 正确的接收完成：上一字节是\r，这一字节是\n。
- 接收错误：上一字节是\r，这一字节不是\n，则表示接收错误。
- 正常接收数据：上一字节不是\r，这次字节保存在buf中。

```c
//7)编写中断处理函数
//串口1中断服务程序，此接收的数据是以0x0D、0x0A结尾为标志的数据帧。
void USART1_IRQHandler(void)
{
u8 Res;
if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾)

{

USART_ClearFlag(USART1, USART_IT_RXNE); //清除标志位

Res =USART_ReceiveData(USART1); //读取接收到的数据

if((USART_RX_STA&0x8000)==0)//接收未完成

{

if(USART_RX_STA&0x4000)//接收到了0x0d

{

if(Res==0x0D)

USART_RX_STA|=0x4000;

else if(Res!=0x0a)

USART_RX_STA=0;//接收错误,重新开始

else

USART_RX_STA|=0x8000; //接收完成了

}

else //还没收到0X0D

{

if(Res==0x0d)

USART_RX_STA|=0x4000;

else

{

USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;

USART_RX_STA++;

if(USART_RX_STA>(USART_REC_LEN-1))

USART_RX_STA=0;//接收数据错误,重新开始接收

}

}

}

}

}

//接收完数据之后，在main函数中对接收到的数据进行处理。

if(USART_RX_STA&0x8000)

{

//得到此次接收到的数据长度，即USART_RX_BUF数组中的有效数据长度

uart1Len=USART_RX_STA&0x3f;

//对接收到的数据进行数据处理，接收的数据暂存在USART_RX_BUF数组中

//... ...

USART_RX_STA=0;

memset(USART_RX_BUF, 0, sizeof(USART_RX_BUF)); //清空数组

}
```



### 应用场景：

- 串口与中控交互
- 连接wifi模块、GSM模块、蓝牙模块等
- 与TTL串口传感器或模块直接通讯
- 转为RS232与PC通讯
- 转为RS485与485部件的传感器或器材通讯





## IIC与SPI

一句话概括：主从设备（有芯片）之间的通信。

**IIC关键词**：两条总线；主从机；寻址；start、ack和stop；

**SPI关键词**：四条总线；单主机；ss线寻址；ss线拉低传输；

### 1、IIC

#### 基本概念

IIC：Inter-Integrated Circuit，内部集成电路。

发展过程：

- 最初嵌入式使用内存映射方式来互联微控制器和外围设备，需大量线路和额外地址解码芯片，不方便、成本高，为节省微控制器引脚和额外的逻辑芯片，研发了IIC。
- 只使用**两根线连接所有外围芯片的总线协议**。
- 7位从设备地址位，能接127个从设备。扩展为10位地址位，可以接的设备数量大大增加。（10位地址：两个字节表示，其中第一个字节：11110[A9] [A8] [R/W]，第二个字节：[A7] [A6] [A5] [A4] [A3] [A2] [A1] [A0]），第一个字节前五位为10位地址标识。



#### 物理层

物理接口：

|          | master                  | slave             |
| -------- | ----------------------- | ----------------- |
| 时钟线   | SCL：Serial Clock       | SCL：Serial Clock |
| 数据线   | SDA：Serial Data        | SDA：Serial Data  |
| 地址设定 | Pout（输出0或1）设定ADO | ADO：Slave Addr   |
| GND      |                         |                   |



电平标准：当IIC设备空闲时，输出高阻态；当所有IIC设备都空闲时，都输出高阻态，然后由上拉电阻将SCL和SDA总线拉高电平（2-15V）。

高阻态：设备空闲时，输出高阻态，即高阻抗状态，（类似浮空状态，不输出高电平，也不输出低电平）其电平高低不影响整个电路，此时其电平由外部电路决定，即放弃了对总线的输出控制。



#### 协议层

协议内容：

- 通信的起始信号
  - 当SCL为高电平时，SDA从高电平切换到低电平，表示起始
- 通信的停止信号
  - 当SCL是高电平时，SDA从低电平切换到高电平，表示停止
- 地址及数据方向：
  - 每一只IIC设备都有一个唯一的7位或10位设备地址；
  - 紧跟地址的下一位表示数据传输方向，即写w（位为0，主机向从机写数据）、读r（位为1，主机由从机读数据）。
- 数据有效性：
  - SDA数据线在SCL的每个时钟周期传输一位数据。
  - **传输时，SCL为高电平时SDA表示的数据有效。**
  - 传输时，SCL为低电平时SDA的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做准备。
- 响应ack：
  - 应答ACK：作为数据接收端（无论主从），当接收到IIC传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答”信号，则发送方会继续发送下一个数据。
  - 非应答NACK：若接收端希望结束数据传输，则向对方发送“非应答”信号，发送方接收到该信号后会产生一个停止信号，结束传输。
  - **传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA控制权，由数据接收端控制SDA，若SDA为高电平，表示非应答信号，低电平表示应答信号。**
- 仲裁
- 时钟同步



通信过程：

- [主设备]发送一个Start信号，类似于广播，然后其他设备开始监听总线以准备接收数据（while循环等待完成）；
- [主设备]发送一个7位设备地址+1位读写操作的数据帧，所有设备接到数据后比对地址，不相符则进入等待状态，等待STOP信号；相符则发送一个应答信号ACK做回应（while循环等待完成）；
- [主设备]接收到应答信号后便开始传送或接收数据：第一步发送写地址，第二步真正开始发送数据。
- 数据传送完毕，主设备发送一个STOP信号，向其他设备宣告释放总线，其他设备回到初始状态。



IIC读写：基本读写基础之上的复合格式

- 第1次传输：主机通过slave地址找到从设备，发送一段数据（通常是从设备内部的寄存器或存储器地址）
- 第2次传输：对从设备上该寄存器地址的内容进行读或写。



**通信几点注意：**

- IIC的SCL和SDA引脚输出模式必须选位开漏输出，因为有3.3V和上拉电阻。（**IIC设备对总线的操作仅有“把线路接地”，从而输出逻辑0**）。
- 总线上的START和STOP必定是唯一的。
- SDA线的数据转换必须在SCL线的低电平期。在SCL线的高电平期，SDA线上的数据是稳定的。

应用：

- OLED：OLED有芯片，充当从机。（IIC软件模拟时序的方式）。
- 两个芯片之间通信：一个芯片数据采集，一个芯片处理，比如MPU6050。
- EEPROM读取数据：



IIC的两种写法：

- 调用库函数
- 直接操作寄存器



#### 通过IMU理解IIC的通信过程

STM32作为主机：主要封装为i2c.c文件实现

- IIC通信建立
- 数据收发函数

IMU作为从机：主要封装为mpu6050.c文件实现

- IMU本身的上电、复位、启动传感器等操作（寄存器操作）
- 从机地址
- 寄存器（读写数据）
- 借助IIC函数收发数据



### 2、SPI

SPI：Serial Peripheral Interface，串行外设接口

发展过程：

物理接口：

- SCLK：Serial Clock（output from master）
- MOSI：Master Output，Slave Input（output from master）
- MISO：Master Input，Slave Output（output from slave）
- SS：Slave Select（active low，output from master，拉低，由主机发送）每个从设备对应一根独立的SS线。

通信过程：

- 主设备向读/写[从设备]时，先拉低[从设备]对应的SS线（SS线是低电平有效）；
- 在响应的脉冲时间上，[主设备]把信号发到MOSI线上，实现“写”；
- 同时，可对MOSI线采样，实现“读”。

四种操作模式：

模式0、模式1、模式2、模式3。区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（即时钟信号无效时是高还是低）。每种模式由一对参数刻画，称为时钟极CPOL（clock polarity）、时钟期CPHA（clock phase）。



### 3、IIC和SPI对比

|                                    | IIC                                                          | SPI                                                          |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 总线拓扑结构/信号路由/硬件资源耗费 | 只需要2根信号线                                              | 至少需要4根信号线，每增加一个从设备，需额外增加一根SS线      |
| 主从关系：master，slave            | 可以做主设备，也可以做从设备                                 | 单主设备，总线中只有一只中心设备能发起通信                   |
| 数据吞吐/传输速度                  | 不是全双工，速度有限制，最高也只能到快速模式1Mbps和高速模式3.4Mbps | 全双工，可高速，能达到10Mbps                                 |
| 总线架构和协议                     | 轻盈架构实现了多主设备仲裁和设备路由                         | 结构简单和支管，容易扩展。但SPI需要在其上构建特定的通信协议软件 |
| 传输数据                           | 字节设备应用                                                 | 数据流应用                                                   |
| 相比Ethernet、USB等总线            | 两者均是“小”协议，适用于系统内各芯片间的通信；而“大”协议适用于系统外的整个系统之间的通信。 |                                                              |



### 



## UART、RS232、RS485、MODBUS

### 发展过程、特点对比

**1、UART串口：**

- 抗干扰能力差：采用TTL电平表示0和1，但TTL信号抗干扰能力差，数据传输时易出错
- 通信距离极短：一般只能用于一个电路板上的两个不同芯片之间的通信



**2、RS232**

- 优点：
  - 采用负逻辑电平信号，电平电压高，在规定范围内的电平信号代表逻辑1和0，弥补了UART的抗干扰能力差、通信距离极短等问题
- 缺点：
  - 电平值较高，易损坏接口电路的芯片，且与TTL电平不兼容，因此需要电平转换芯片才能与TTL电路连接
  - 通信速度较低
  - 接口使用一根信号线和一根信号返回线而构成共地的传输形式，这种共地传输容易易产生共模干扰，抗噪声干扰性弱
  - 传输距离较短（15m）
  - 不能实现多机通信，只能实现点对点通信

**3、RS485**

- 优点
  - 接口电平低，为两条线的差分信号+(2-6)V表示1，-(2-6)V表示0。
  - 传输速度快：10m时，可达35Mbps；1200m时，可达100Kbps。
  - 抗干扰能力强：平衡驱动器和差分接收器组合，抗共模干扰能力强。
  - 传输距离远，支持多节点：总线形式，最长可传输1200m以上；可支持32个节点甚至更多
  - 对于MCU来说，485仅仅是使用电平转换芯片将TTL电平转成485电平，所以485传输，本质上还是串口传输。
- 缺点
  - 差分信号，同一时刻只能是发送或接收的一种，半双工通信。效率上比RS232弱。
  - 需要额外设置一个引脚，作为接收或发送的标志位/使能信号。
  - 多机通信时，从机地址和命令码需要更复杂的协议层来确定：主机与从机通信需要地址和命令码，SPI可以通过拉低片选信号来选择某一从机，而RS485从机地址的确定需要一套更复杂的软件协议（即简单的物理层，决定了其必须使用更复杂的协议层，以实现复杂功能），因此诞生了Modbus通信协议。
  - 多机通信时，不能做总线的自动仲裁，即不能同时发送数据以避免总线竞争，所以整个系统的通信效率低，数据冗余量大，对速度要求高德场所不适用RS485。

**4、MODBUS**

特点：不定义物理层内容，因此能适应多种物理接口，比如RS232、RS485等

定义了一种数据帧格式：（协议很灵活，目的是定义数据格式，可根据需要裁剪）

标准modbus协议格式：帧头---地址---功能码---数据---CRC校验。

（详见通信协议章节）



**UART、RS232、RS485三者对比总结：**

- 相同点：协议层本质上采用的都是串口通信协议（波特率、数据位、停止位、校验位等）
- 不同点：三者区别在于物理层不同，接口电平、接线方式等



**UART、IIC、SPI三者对比：**

- 三者都是基于串行通信的理论而研发出的实际串行通信应用，所谓的IIC通信协议只是对该应用的规范。



























## CAN

### 基本概念

CAN：



应用场景：汽车、工业环境

特点：抗干扰、



### 物理层



#### 结构框图与总线网络

结构框图：控制器、收发器、两根总线、电阻



分类：

- 闭环
- 开环

通信节点



#### 接口



#### 差分信号



### 协议层





## 硬件调试

### 1、串口调试

UART，通用异步收发器，是电脑硬件的一部分。把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连接上。

调试过程：通过UART串口来直接与机器交互，通过串口输出输入信息，做动态调试。

UART、COM：指的是物理接口形式（硬件），（USB最终在电脑上是一个虚拟的COM口）。

RS232、TTL：指的是电平标准（电信号）。

UART用的TTL电平，低电平0（0V）、高电平为1（3.3V），其RXD、TXD引脚一般直接与处理器芯片的引脚相连。

RS232串口的RXD、TXD等一般需要经过电平转换（通常由Max232等芯片进行电平转换）才能接到芯片的引脚上，否则高电压会把芯片烧坏。

### 2、JTAG调试



### 3、JTAGulator调试



### 4、远程调试



# 物联网

## 架构

### 三层架构

- 应用层
- 网络层
- 感知层



### 四层架构

- 应用层
- 平台层：即物联网云平台
- 网络层
- 感知层



物联网平台分类：





## 通信基本概念

- 通信机制
- 通信协议
- 数据格式



## 通信协议

完成硬件产品由多种模块组合实现产品功能。

核心：MCU大脑 

外围：存储单元+显示单元+发声单元+传感器单元+运动单元

通信协议：连接不同类型的硬件单元。



**软件模拟协议**：以IIC为例说明，通过微控制器的GPIO引脚，分别用作SCL和SDA，按照其信号时序图输出响应信号，就可以实现IIC通信。同样以此可实现USART通信。直接控制GPIO引脚电平产生通信时序，需要CPU控制每个时刻的引脚状态，所以称为“软件模拟协议”。

**硬件协议**：物理层（电平标准）+协议层（电平的含义）。由STM32上的IIC片上外设专门负责实现IIC通信协议，只要配置好该外设即可。CPU只要检测该外设状态和访问数据寄存器，就能完成数据收发。这种由硬件外设处理IIC协议的方式减轻了CPU的工作，使软件设计更加简单。

**软件通信协议**：





基础协议：仅封装了基本数据包格式的协议（基于数据位）

高层应用协议：使用基本数据包组合成通信帧格式的高层应用协议（基于数据包或字节）



### 0、软件模拟协议

**软件模拟协议**：以IIC为例说明，通过微控制器的GPIO引脚，分别用作SCL和SDA，按照其信号时序图输出响应信号，就可以实现IIC通信。同样以此可实现USART通信。直接控制GPIO引脚电平产生通信时序，需要CPU控制每个时刻的引脚状态，所以称为“软件模拟协议”。



### 1、硬件通讯（接口）协议

#### （1）物理层

- TTL电平：
- RS-232电平：

|                   | 电平标准（发送端）                   | 信号线      | 通信方向 | 传输距离 | 通信节点     | 特点                                                         |
| ----------------- | ------------------------------------ | ----------- | -------- | -------- | ------------ | ------------------------------------------------------------ |
| TTL（5V、3.3V）   | 逻辑1: 2.4V-5V，逻辑0: 0V-0.5V       |             |          |          |              | 常见电子电路中采用TTL电平                                    |
| RS-232            | 逻辑1：-15V - -3V，逻辑0：+3V - +15V | TX、RX、GND | 全双工   | 100m以内 | 只有两个节点 | 高电压能够增加串口通信距离和抗干扰能力，因此常用RS-232线，配以RS-232转TTL芯片，实现两个控制器间通信 |
| 差分信号（RS485） | 逻辑1：-6V - -2V，逻辑0：+2V - +6V   | 差分线AB    | 半双工   | 1200m    | 支持多节点   | 支持多个主设备，任意节点间可互相通信。抗干扰性能强（适合工业环境） |



#### （2）协议层

数据包：由发送设备的TXD接口，传输到接收设备的RXD接口。

协议层中，规定了数据包的内容，由起始位、主体数据、校验位以及停止位组成。

- 波特率：由于是异步通信，没有时钟信号，因此两个设备间要约定好波特率，即每个码元的长度，以便对信号解码。
- 起始位和停止位：起始位一个逻辑0，停止位可由0.5、1、1.5、2个逻辑1的数据位表示。
- 有效数据：常约定为5、6、7、8位长。
- 数据校验：奇校验、偶校验、0校验、无校验等。



|       | 物理层 |          |      | 协议层 |
| ----- | ------ | -------- | ---- | ------ |
|       | 电平   | 物理接口 | 寻址 | 时序图 |
| USART |        |          |      |        |
|       |        |          |      |        |
|       |        |          |      |        |





解决逻辑传输方式。

- UART：stm32的uart输出TTL电平。

发送移位寄存器和接收移位寄存器有多少位？

- IIC
- SPI
- CAN
- USB
- RS485
- RS232

### 2、软件协议（高级应用协议）

数据格式：头+内容+尾，头+内容长度+内容+尾。

#### AT指令

##### 基本概念

AT指令和ESP8266的关系：

**ESP8266：**

- 是一款WIFI功能的MCU，内置完整的TCP/IP协议栈
- 固件两种方式：
  - 内部烧写了固件，允许我们用AT指令去控制它
  - 用SDK的方式，去重新烧写固件，添加我们自己的AT指令

**AT指令：**

- 即Attention，是应用于终端设备与PC应用之间的连接与通信的指令

- 是一套指令集，有统一的格式

- 各厂家可自定义功能，在统一格式基础上，自定义实现不同功能的命令



##### 配置过程与常用命令

- 初始化：
  - AT：测试连接
  - AT+RST：重启
  - AT+RESTORE：恢复出厂设置，将所有保存参数恢复到出厂设置+重启
  - AT+UART：设置串口配置，设置会保存在flash，断电重启后仍生效
- 配置局域网连接：设置AP/STA模式、连入局域网或路由（设置保存在flash，断电重启后仍生效）
  - AT+CWMODE：设置sta、ap或兼有模式
  - AT+CWJAP=“ssid”，“passwd”：加入局域网
  - AT+CWSAP=：设置AP模式下的参数
- 配置TCP、UDP连接，数据传输：
  - CIPSTATUS：查询连接状态
  - CIPSTART：建立TCP连接或注册UDP端口
  - CIPCLOSE：关闭TCP连接或UDP连接
  - **CIPSEND=len：**发送长度为len的数据
  - **+IPD：**接收网络数据（是模块发出指令，当模块接收到网络数据时，由模块向串口发送+IPD和数据），+IPD,< len >:< data >
- SYS工具：使能、关闭看门狗等
- IO工具：
  - AT+CIOBAUD：设置串口配置
  - AT+CIOADC：读取IO口的ADC数据
  - AT+CIOREAD：读取gpio状态
  - AT+CIOWRITE：设置gpio状态



##### AT发送接收函数和USART发送接收函数过程

过程：

| 过程 | 函数本质             | 函数名              | 发送内容                                                     |
| ---- | -------------------- | ------------------- | ------------------------------------------------------------ |
| 1    | 库函数，二进制数     | USART_SendData      | 发送uint16_t的data（单字符）（低8位为数据，最高有效位1位为校验位，共9位有效位） |
| 2    | 基于库函数的发送函数 | UART_SendStr        | 通过串口，连续发送长度为len的字符串                          |
| 3    | AT发送函数           | AT_Send             | （1）调用UART_SendStr<br />（2）发送AT指令格式的数据，并将返回结果保存在temp[]或recv[]缓存区<br />（3）用于命令对比确认 |
| 4    | WIFI_Send发送函数    | ESP_Send或WIFI_Send | （1）调用AT_Send<br />（2）发送AT+CIPSEND指令，从而发送len长度的数据<br />（3）将返回结果保存在recv[]缓存区，用于下一步数据处理 |





##### 使用注意：

- 单条指令的形式
- 每行命令必须以回车换行“\r\n”结束



#### Modbus

##### 基本概念

定义：是工业现场的总线协议。

- **单主机、多从机，支持247个从机**（1字节共8位表示地址，其中0x00为广播地址，从1到247为从机地址，从248到255为预留）
- 标准的Modbus口是使用RS232C兼容串行接口。支持多种电气接口，如RS232，RS485等。



特点：

- 控制器相互之间、控制器经由网络（以太网等）和其他设备之间可以通信
- 不同厂家生产的控制设备可以连成工业网络，进行集中监控。
- 可在各种介质上传输，如双绞线、光线、无线等



应用场景：

- 工业现场的总线协议，应用于工业中带智能终端的可编程序控制器和计算机，通过局部专用线路连接组网
- 主要用于各种数据采集和过程监控
- 工业设备，包括PLC，DCS，智能仪表等都在用Modbus协议作为他们之间的通讯标准。



##### 传输方式

主从传输方式：**查询+回应**的方式

- 主：
  - 单独与从设备通信（查询）：从设备返回消息作为回应（回应）。【查询数据格式】
  - 广播与所有从设备通信：从设备不做任何回应。
- 从：
  - 正确回应：【回应数据格式】
  - 错误回应：若从设备不能执行主设备命令，或消息接收过程发生错误，则从设备将建立一错误消息并作为回应。



##### 传输模式

在配置每个控制器时，同一个Modbus网络上所有设备必须选择相同的传输模式和串口参数。这两种模式定义了连续传输的消息段的每一位，以及决定怎样将信息打包成消息域和如何解码。

- ASCII模式：
  - 传输的是可见的ASCII字符
- RTU模式：远程中断设备



对比：

- ASCII传输有开始和结束标记，因此程序处理更方便
- 传输一个0XF9，RTU只需要一个字节即可传输，而ASCII需要传输'F'和'9'两个字符，即需要两个字节。因此RTU传输效率高。



##### 数据类型

"线圈"：位变量。

“寄存器”：16位变量。每个寄存器表示一个16位无符号整型。



4种基本数据类型：

| 地址类型             | 映射地址 | 读写            |
| -------------------- | -------- | --------------- |
| 数字输入，离散量输入 | 1xxxx    | 读+写，位数据   |
| 数字输出，线圈输出   | 2xxxx    | 只读，位数据    |
| 模拟输入，输入寄存器 | 3xxxx    | 只读，16位数据  |
| 模拟输出，保持寄存器 | 4xxxx    | 读+写，16位数据 |



在单片机中拿出一部分RAM，进行两个设备通讯

```c
u8 OX[20];	/*8位数组，输出线圈	功能码：0x01,0x05,0x0f	地址：0x*/
u8 IX[20];	/*8位数组，输入线圈	功能码：0x02			地址：1x*/
u16 InDataReg[30];	/*16位数组，输入寄存器	功能码：0x04			地址：3x*/
u16 HoldDataReg[30]	/*16位数组，保持寄存器	功能码：0x03,0x06,0x10	地址4x*/
```





##### RTU数据帧（数据格式）

1、主设备消息格式：

[地址] [功能码] [数据地址] [数据] [CRC校验]

- 起始：消息发送至少要以3.5个字符时间的停顿间隔开始（怎么实现？？？？）
- 设备地址：16进制发送。网络设备不断侦听网络总线，包括停顿间隔时间。收到后解析地址。
- 功能码：收到消息后解析功能码
- 数据：
- CRC校验：
- 结束：一个至少3.5个字符时间的停顿，标记了消息的结束

|      | 起始位      | 设备地址 | 功能码 | 数据  | CRC校验 | 结束符      |
| ---- | ----------- | -------- | ------ | ----- | ------- | ----------- |
| 长度 | T1-T2-T3-T4 | 8 bit    | 8 bit  | n bit | 16 bit  | T1-T2-T3-T4 |



功能码列表：详见协议手册。



2、从设备回复消息格式：

根据功能码确定从消息回应格式

|      | 起始位      | 设备地址 | 功能码 | 数据  | CRC校验 | 结束符      |
| ---- | ----------- | -------- | ------ | ----- | ------- | ----------- |
| 长度 | T1-T2-T3-T4 | 8 bit    | 8 bit  | n bit | 16 bit  | T1-T2-T3-T4 |



- 正确消息格式：
- 错误信息：



错误消息：

- 整个消息帧必须是连续的流传输。
- 如果在数据帧完成之前有超过1.5个字符时间的停顿，则接收设备将刷新不完整的消息，并假定下一字节是一个新消息的地址域，重新开始侦听总线。
- 如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续，这将导致一个错误，因为最后的CRC校验不可能正确。



##### ASCII数据帧（数据格式）



##### 缓存



- 串口接收缓存：RecvBuf[]
- 



##### 函数



- 任务处理函数：
  - 先判断地址
  - 再判断功能码，根据不同功能码，执行不同功能函数
  - 具体的各类功能函数







## 有线通信





## 无线通信

### WIFI

#### 架构



数据封装与发送的过程：

- UART收发数据：stm32通过uart发送数据
- AT指令：遵循AT协议的命令，通过uart发送和确认，从而配置wifi，将stm32设为sta端，可连上服务端
- stm32向服务端发送数据：





#### 配置过程（详见AT指令章节）

将wifi模块与串口工具相连，然后串口转usb连接至电脑，通过串口调试助手，使用AT指令，配置wifi模块连接至局域网。

1、wifi模块的测试

- 串口（通断）测试：AT：连接测试

- 模式设置：AT+CWMODE=1：client端（STA）/server端配置（AP）。配置为STA端还是AP端。

- 接入AP设置：AP名称和密码设定，AT+CWJAP_DEF="sh","12345678"

- 获取wifi模块的IP地址：AT+CIFSR

  +CIFSR:STAIP,"192.168.0.107"
  +CIFSR:STAMAC,"fc:f5:c4:98:91:a2"

- 连接到TCP服务器：AT+CIPSTART="TCP","ip",333

- 向服务器发送数据：AT+CIPSEND=10（表示发10个字符）



2、将wifi模块通过UART2连接到stm32（UART1用于stm32与电脑串口通信）



#### 原理



ESP模块

- 



AT函数：at_send（）

- 传参：AT命令字符串；实际返回结果；预期正确返回结果；等待时长
- 函数：通过uart_send_data函数发送AT命令，比较实际返回的字符串与预期正确结果是否相同，相同则表明发送成功。
- 全局变量：实际返回结果由一个esp_recv[]数组记录，esp_recv在uart中断函数中，esp_recv[esp_recv_flag++] = USART_ReceiveData(UART2)得到。







### BT



### zigbee

zstack协议：TI德州仪器设计的

精简协议栈



#### zigbee网络入门

网络建立和节点加入：调用API，组网函数和加入网络函数

发送设备：无线数据发送函数

接受设备：接收函数



## 中间件

定义：一种系统软件平台，为网络应用软件提供综合的服务和完整的环境，借助这种软件使得网络应用、硬件数据能够实现集成。

中间件 = 平台 + 通讯。

两种模式：

- 模式一：下层是操作系统，上层是应用软件。中间件能管理计算机资源和网络通讯，将操作系统与应用软件连接起来，实现信息传递和交互。（为应用程序提供操作系统通用服务和功能）
- 模式二：下层是硬件，上层是应用软件。中间件管理、集成硬件设备， 将硬件数据信息集成并上传给应用软件。

两种模式中，中间件都可以向下集成处理，向上直接为系统软件体统数据等资源。



工作原理和过程：

- 前端传感器->数据采集模块：通过数据采集模块将大量设备信息进行采集；
- 中间件（中间协议转换平台）：将采集的数据转换成统一可识别的通信协议；
- 上送后台服务器：经过转化后的相互可识别的数据信息上传至后台服务器，进行统一存储、分析和管理。



特点：

- 与设备灵活对接：设备信息采集和数据传输。
- 实现互操作：同一个信息采集设备所采集的信息可能要供给多个应用系统，不同的应用系统之间的数据也需要相互共享和互通。



应用：

- 工业物联网平台中间件：向下连接工业物联网硬件，向上对接业务软件，提供标准数据接口，是系统集成的利器。
- 智能家居（传感器）网关中间件：点灯、冰箱等不同的终端产品支持不同的通讯协议，有的支持wifi、BT，有的支持zigbee，有的支持Z-ware，这样不同的产品就无法实现互联互通。通过智能家居**网关中间件**解决各类产品的通讯障碍，实现互联互通。





## 组网技术









### 从zstack顶层深入学习





# Peripheral

外设器件

| 序号 | 模块 | 类型     | 外设                       |
| ---- | ---- | -------- | -------------------------- |
|      | GPIO | 基本IO   | LED                        |
|      |      | 时序图IO | 温度传感器                 |
|      | ADC  | 采样     | 光敏电阻传感器             |
|      |      |          |                            |
|      | TIM  | 时基单元 | delay函数                  |
|      |      | 输入捕获 | 按键输入时长               |
|      |      | 输出比较 | PWM，占空比，控制LED灯亮度 |
|      | 综合 | 矩阵键盘 | 外部中断、轮询机制         |
|      | 综合 | OLED     |                            |



通信模块

| 序号 | 模块  | 类型         | 外设                           |
| ---- | ----- | ------------ | ------------------------------ |
|      | USART | 串行通信     |                                |
|      | IIC   |              | 显示屏，EEPROM，主从机之间通信 |
|      | SPI   | 串行外设接口 | 外接显示屏，FLASH，MCU等       |
|      | WIFI  |              |                                |
|      | BT    |              |                                |







## 矩阵键盘



结构组成：C为column列，R为row行，组成矩阵。

操作步骤：

- 轮询：先行扫描，再列扫描
- 中断：



## OLED

基本概念：

结构组成：

- LED裸屏
- 通信模块：SPI/IIC模块（7引脚）、IIC模块（4引脚）
- OLED驱动IC：每页128（或132）字节，共8页等。编程时注意程序显示地址修改。



操作步骤：

- 接口定义与电线连接
- 操作函数
- 字符取模



# FreeRTOS

## （一）链表/列表



## （二）任务创建与调度

### 任务创建和初始化

任务的管理：TCB（Task Control Block），所以最终任务创建成功返回指向TCB的句柄指针（TaskHandle_t *）。

处理三个内容的关系：TCB、Stack、List。

- TCB：包含4块内容：TopOfStack、Stack、ListItem、Name。
- Stack：本质就是个StackType_t（uint32_t）类型的数组，是存储该任务的变量、函数等的栈。
  - StackBuffer：
  - Length：
  - TopOfStack：根据Stack起始地址和Length，求出TopOfStack地址，做8字节对齐处理，依次存放CPU自动从栈中加载到CPU寄存器的内容，包括任务函数TaskCode入口地址、任务的返回地址（通常不返回，若返回则为ExitError的无限循环函数）等，以及异常发生时需手动加载到CPU寄存器的内容。最后返回TopOfStack的地址，即为可用于程序运行的空闲栈。
- List：用于挂载各个任务。



### 任务插入到就绪列表

作用：把创建完成的任务全部统一管理，根据其优先级，放入链表数组相应优先级索引下的链表中。

过程：

- 就绪链表数组初始化：链表类型的数组，每个索引对应一个优先级，每个数组第一个元素为根节点，在此根节点上插入相应优先级的任务
- 插入任务节点



### 任务调度（切换）

在task.c中用启动任务调度器和任务切换函数，分别调用port中的汇编函数，实现任务往寄存器的加载；通过中断函数实现任务的切换。



#### 启动任务

- 设置pxCurrentTCB
- 配置PendSV和SysTick的中断优先级为最低
- 调用汇编函数，加载相关信息；通过SVC_Handler中断，真正去启动第一个任务



#### 切换任务

- 触发PendSV中断，产生上下文切换
- 在PendSV中断中，切换pxCurrentTCB
- 再次启动任务



<u>**重点要理解SVC_Handler、SysTick_Handler、PendSV_Handler中断**</u>

#### SVC_handler



#### SysTick_handler



#### PendSV_handler



#### 临界段保护

临界段，一段在执行时不能被终端的代码段。比如对全局变量的操作，全局变量就像一个靶子，谁都可以对它开枪，但当某人开枪时，别人就不能再开枪。

临界段什么情况下会被打断？一个是系统调度，一个是外部中断。二系统调度最终也是产生PendSV中断，在PendSV_Handler中实现任务的切换，所以还是归结为中断。所以对临界段的保护最终回归到对中断的开和关的控制。

**（中断关，则临界段保护，不会被打断；中断开，则临界段可能会被中断打断）**。





## （）内存管理



## （）中断机制



## （）队列管理



## （）事件管理



## （）IPC机制



## （）时间管理





# 开发环境

## Keil5





## VSCode





# 工具类

## qemu操作



启动qemu与gdb调试

```

```





## gdb操作







## makefile操作



# 名词与缩写

- MSB：Most Significant Bit，最高有效位
- LSB：Least Significant Bit，最低有效位







# 重难点理解

## printf函数重写？？？

用fputc重写printf函数的原理。
