





### 编码表示各类对象

#### 表示数字

整数

浮点数



#### 表示字符串

ASCII编码表：



#### 表示代码





## 2021.10.26

cppreference：

- priority_queue：using lambda to compare elements用法练习。









- 

# Question



## 基础

### C++与C对比



|              | C                                                            | C++                                                          |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 编程范式     | 面向过程：（1）函数、传参。（2）struct：数据类型的集合。（3）多个函数，封装性不够好。单个变量类型，单个函数。 | 面向对象：封装、继承、多态。（1）struct：扩展了成员属性、方法等。（2）class类和对象，类的成员属性、成员方法。增强了封装性、模块化。一类的属性、对应的方法，形成了类和对象。 |
|              |                                                              |                                                              |
|              |                                                              | 泛型编程：模板，STL中容器、迭代器、算法，多态等              |
|              |                                                              | 函数式编程：lambda函数                                       |
|              |                                                              |                                                              |
| 动态内存分配 | malloc和free                                                 | new和delete，两步：分配内存，构造和析构                      |
| 字符串       | char字符串                                                   | string字符串类                                               |

**泛型编程：genetic**

- 定义：就是不使用具体的数据类型，比如int，double，char等，而是使用一种通用类型来进行程序设计，泛泛的描述一下数据，从而可以大规模的减少程序代码量。

   对比多态，函数重载还是需要指定多种数据类型才能实现，因此代码量多。

- 实现方式：template模板，包括函数模板和类模板。（模板）template< class T >，T就是数据类型占位符，叫做泛型（generic type）。

- 实例：STL容器、迭代器和算法，多态。





### struct和class的区别



|                | struct                                                       | class                                                        |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用           | 数据结构集合                                                 | 对象                                                         |
| 内容           | C中只是数据类型的集合，不涉及算法和操作；C++进行了扩充，也可以拥有class内容 | 对数据类型集合、算法和操作的封装                             |
| 防控属性       | 默认public                                                   | 默认private                                                  |
| 继承中防控属性 | 默认是public                                                 | 默认是private                                                |
| 模板中使用     | struct不可                                                   | 可用来定义模板参数，与typename类似                           |
| {}赋初值       | C中用{}赋初值可行                                            | C++中当struct中有构造函数或其他类似class的情况时，不能用{}赋初值 |



- struct内存对齐：

```c++
//若只有一个变量且不超过8字节，则整体输出实际字节数(比如只有bb，则输出4；只有cc，则输出1)；若两个及以上变量，且和不超过8，则占8字节。
struct {
int bb;
char cc;
}
```





### 内存分区

#### （1）栈区

- 栈内存：保存定义在函数内的非static对象

- 变量类型：分配在静态或栈内存中的对象，里面的变量常是局部变量、函数参数等。

- 创建和销毁：由编译器自动创建和销毁。

- 生存期：进入其程序块时生成，离开其程序块时结束。



#### （2）堆区

- 堆（heap）/内存池：这部分内存被称为自由空间（free store），用来存储动态分配（dynamically allocate）的对象。




- 变量类型：new创建的对象

- 创建和销毁：在程序运行时分配；必须显式的销毁。**（显式的销毁就引出了动态内存管理的问题，包括显式内存释放、智能指针等）**

  如果程序员不显示销毁，则在程序结束时释放。但对于长期运行的服务器等，则会出现内存泄露。

- 生存期：运行时，显示销毁。



#### （3）全局/静态存储区

- 全局变量和静态变量被分配到同一块内存中。在所有函数体外定义的是全局变量。加了static修饰符后不管在哪里都存放在全局区（静态区）。

  **注意：在所有函数体外定义的static变量表示在改文件内有效。不能extern到别的文件用。**

- 变量类型：全局变量、静态变量

- 创建和销毁：

- 生存期：



静态内存：保存局部static对象、类static数据成员、定义在任何函数之外的变量





#### （4）常量存储区

- 定义：是一块比较特殊的存储区，里面存放的是常量，不允许修改。
- 变量类型：常量
- 创建和销毁：程序结束后由系统释放。
- 生存期：



#### （5）程序代码区

- 存放函数体的二进制代码
- 





#### （00）栈和堆的对比

|              | 栈                                                           | 堆                                                           |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 底层机器代码 | 是机器系统提供的数据结构（有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈出栈的操作）（特点是效率高，支持的数据有限，一般是整型、指针、浮点数等系统直接支持的数据类型） | 是C/C++函数库提供的数据结构（基本的malloc、realloc和free等函数维护了一套内部的堆数据结构，相当于一个内存分配的缓冲池cache） |
| 空间大小     | 一般是2M，可能有所区别                                       | 可以分配很大内存                                             |
| 特点         | 优点是快速高效；缺点是有限制，数据不灵活                     | 优点是灵活方便，数据适应面广，缺点是效率有所降低             |







- 

|                      | 范围             | 内容                                                         | 生存期                                   |      |
| -------------------- | ---------------- | ------------------------------------------------------------ | ---------------------------------------- | ---- |
|                      |                  |                                                              |                                          |      |
| 静态内存区           |                  | 局部static对象、类static数据成员、<!--定义在任何函数之外的变量--> | 在第一次使用前分配，在程序结束时销毁     |      |
| 栈区（局部自动对象） | 被定义的程序块内 | 保存定义在函数内的非static对象                               | 进入其被定义的程序块时创建，离开块时销毁 |      |
| 堆区                 |                  |                                                              | 运行时分配，不用时显式的销毁             |      |
|                      |                  |                                                              |                                          |      |
| 全局对象             | 程序范围         |                                                              | 程序启动时分配，程序结束时销毁           |      |
| 常量区               |                  |                                                              |                                          |      |
| 代码区               |                  |                                                              |                                          |      |
|                      |                  |                                                              |                                          |      |





### 动态内存管理与智能指针

针对堆区的内存的分配、释放、内存泄露、智能指针管理

#### （0）使用动态内存的情形和原因

程序使用动态内存主要处于以下三种原因：

- 程序不知道自己需要使用多少对象（容器类的情形）
- 程序不知道所需对象的准确类型
- 程序需要在多个对象间共享数据（智能指针的情形）



#### （1）new/delete与malloc/free

malloc和free是单纯的动态分配内存和释放内存。

C++中有了类和对象的概念，因此使用new为对象分配内存时，会分两步：一是分配内存，二是调用构造函数，对该对象进行初始化。delete同理，先调用析构函数，再释放内存。

new返回的类型和地址和operator new返回的类型和地址并不完全相同。







#### （2）new[]和delete[]

new[]申请到的内存比真是数组内存大8个字节，比第一个元素[0]的地址往前偏移了8个字节，这8个字节用于保存数组长度。

delete[]时，就会使用这个长度值自动遍历释放空间。



练习：operator重载new/delete，new[]/delete[]，看看分配的内存的地址和返回的类型。



#### （3）内存泄漏与引用非法内存指针

内存泄露：动态分配了内存，使用完后没有释放内存，就会产生内存泄露。（用完了，没释放）

引用非法内存的指针（野指针）：动态分配了内存，尚有指针引用该块内存时，如果释放了该块内存，就会产生引用非法内存指针。（还在用，但释放了）



#### （4）智能指针

本质：类。

作用：当超出了类的作用域时，类会自动调用析构函数（原理类似reset方法），自动释放指针，引用计数减1。为了更容易、更安全的使用动态内存。

智能指针类似常规指针，重要区别是它负责自动释放所指向的对象。

头文件：#include < memory >。

两种智能指针：shared_ptr和unique_ptr。

##### auto_ptr（c++11已抛弃该用法）

auto_ptr的p2对象取代原p1对象。

```c++
auto_ptr<string> p1(new strint("hello world!"));
auto_ptr<string> p2;
p2 = p1;//不会报错

//p2剥夺了p1的所有权，当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。
```

##### unique_ptr

该指针独占所指向的对象，保证同一时间只有一个智能指针可以指向该对象。对于避免内存泄露特别有用。

赋值时，如果是右值可以，如果非右值不可。（可使用std::move转化为右值）



##### shared_ptr

允许多个指针指向同一个对象，实现共享式拥有的概念。该对象和其他相关资源会在最后一个引用被销毁的时候释放。

构造：可通过new构造，还可通过传入auto_ptr、unique_ptr、weak_ptr来构造。

释放：当调用release()时，当前指针会释放资源所有权，计数减1。当计数为0时，内存资源会被释放。

成员函数：

- 初始化：

- use_count()：返回引用计数的个数（即总共有多少个指针指向该对象）

- get()：返回内部对象（指针），由于重载了（），因此和直接使用对象是一样的。比如

  ```c++
  shared_ptr<int> p1(new int(1));
  //p1.get()和p1是等价的
  ```

- swap：交换两个shared_ptr对象

- reset：放弃内部对象的所有权，原有对象的引用计数减1

- unique：返回是否是独占所有权（仅针对shared_ptr有用）



##### weak_ptr

问题：当两个对象相互使用一个shared_ptr成员属性指向对方，会造成循环引用，使引用计数失效，从而导致无法析构，造成内存泄露。

伴随类，是一种弱引用，指向shared_ptr所管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr，weak_ptr只提供了管理对象的一个访问手段。

目的是为配合shared_ptr工作，它可以从一个shared_ptr或另一个weak_ptr对象构造，但它的构造和析构不会引起引用计数的增加或较少。

作用是解决shared_ptr相互引用时的死锁问题。如果两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不能释放。



### sizeof和strlen的区别



|        | sizeof                                                       | strlen                                                       |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本质   | 运算符                                                       | 函数                                                         |
| 阶段   | 编译阶段                                                     | 运行时                                                       |
| 参数   | 类型（int， char，double等）、数组、指针、函数、对象（对比struct内存对齐问题） | 字符型指针，且必须是以'\0'结束的。当传入数组名时，数组退化为指针 |
| 返回值 | 返回类型，静态分配的对象、结构或数组所占的空间。不能用来返回动态分配的内存空间。参数是字符串时，返回值包括'\0'所占空间。 | 返回字符串长度，直到遇到'\0'为止。不包括'\0'所占空间。       |

sizeof返回值：

- 类型：类型所占的空间大小，比如int为4字节，double为字节，char为1字节

- 数组：编译时分配的数组空间大小（静态分配）

- 指针：存储该指针地址所用的空间大小

- 函数：函数的返回类型所占的空间大小。函数的返回类型不能是void<!--（测试一下）-->

- 对象：对象成员属性所占空间大小<!--（测试一下对象中有成员函数的情况？成员函数不占内存空间）-->

  类中有虚函数时，虚函数表指针占8字节大小（64位系统）（32位系统中占4字节大小）。

```c++
//特别注意
char *s1 = "abcde";
char s2[] = "abcde";
sizeof(s1) = 8;
sizeof(s2) = 6;
strlen(s2) = 5;


```



### 指针和引用的区别？

使用总结：

指针：不指向任何对象（或者说指向空），或者可以指向任何对象（重新赋值），要用指针。

引用：总是代表某个对象，且一旦代表了就不能更改，要用引用。operator[]重载中括号进行赋值时要用引用。

```c++
vector<int> vec(10);
vec[5] = 10;//赋值操作

//若用指针，则此时应写为：
*vec[5] = 10;
//所以operator[]重载函数要返回reference。
```



|                | 指针                                      | 引用                                                         |
| -------------- | ----------------------------------------- | ------------------------------------------------------------ |
| 实体存在的角度 | 是真正存在的对象（如同int，double等一样） | 是语法上的概念，是一个对象的别名                             |
|                | 储存它所指向的对象的内存地址              | 用于绑定到一个对象上，对引用的操作就完全等同于对其所绑定对象的操作 |
|                | 编译器一定会为其分配内存                  | 虽然在内存上储存对象的内存地址是编译器实现引用的一种常用方式。但编译器不一定总是会为引用分配内存 |
| 是否能指向null | 可以指向空，可以定义时不赋初值。          | 不可以指向空。所以初始化时必须明确所引用对象；操作时不需要判空，提高了效率。 |
| 赋值操作       | 可以重新赋值，指向另一个对象              | 不可以重新赋值，只能指向最初引用的对象                       |
|                |                                           |                                                              |



### 关键字总结

#### （1）auto（typeid）与decltype

作用：自动推导类型

时期：作用在编译阶段

不能用于以下场景：

- 与引用、const int等类似，必须在定义时直接初始化，否则无法推导。

- 不能用于数组定义：有可能是类对象的定义，无法推导出是数组好使类对象的构造。

- 不能用于非静态成员属性（非静态成员属性是在运行时才定义，在编译阶段不体现）

- 特殊情况：c++11不能用于函数传参，包括（非静态）类成员函数、模板函数。c++14后可用于函数传参。

  

decltype：



#### （2）constexpr与const



|           | 相同点                                         | 不同点                                                       |
| --------- | ---------------------------------------------- | ------------------------------------------------------------ |
| const     | 都是常量修饰符，被修饰的变量都不能执行++操作等 | 运行时常量，在运行阶段执行                                   |
| constexpr |                                                | 编译阶段执行。在编译阶段就会计算好，如果编译时无法计算，就会报错。 |
|           |                                                |                                                              |



作用：

- 修饰函数
- 修饰普通函数
- 修饰构造函数：必须对构造函数进行初始化，否则构造函数在运行时才会初始化，就会报错。

#### （3）final

final是维护继承关系的一个关键词，所以主要用于继承和虚函数的重写两部分。

作用：

- 修饰类时，表示不允许类的继承了
- 修饰虚函数时，表示不允许虚函数的重写了

注意final的位置。

#### （4）override

在继承中，子类中虚函数重写时的修饰，写与不写都可，写了会增强代码阅读性，表明该方法是对父类虚函数的重写。

#### （5）nullptr和NULL

c++中空指针时要用nullptr。

|         | C        | C++      |
| ------- | -------- | -------- |
| NULL    | (void*)0 | 0        |
| nullptr | /        | (void*)0 |
|         |          |          |



## 模板



### 右值引用的作用？

解决两个问题：

- 一是临时对象非必要的昂贵的拷贝操作；
- 二是在模板函数中如何按照参数的实际类型进行转发。



左值

纯右值

将亡值



右值引用的几个特点：

- 通过右值引用的声明，右值又“重获新生”，其 生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。
- 右值引用独立于左值和右值。即右值引用类型的变量可能是左值，也可能是右值。
- T&& t在发生自动类型推导的时候，它是未定的引用类型（universal reference），如果被一个左值初始化，它就是一个左值；如果被一个右值初始化，它就是一个右值。完全取决于初始化。



引用折叠：

- 所有的右值引用叠加到右值引用上仍然还是一个右值引用。
- 所有的其他引用类型之间的叠加都将变成左值引用。



应用在类的构造函数中：移动构造

原由：如果是一个带有堆内存的类，必须提供一个深拷贝（深拷贝：堆内存的内容也另开辟一块堆内存，进行拷贝）的拷贝构造函数（因为默认的是浅拷贝，会造成“悬挂指针”的发生）。虽然深拷贝解决了“指针悬挂”问题，但每次深拷贝都会产生临时变量（拷贝后产生的临时值就会销毁），若是要拷贝的内容过大，则就会造成不必要的性能开销。

所以才有了传递右值引用变量，解决深拷贝临时变量性能额外开销的问题。





拷贝构造，堆空间，深拷贝，临时变量和性能开销。移动构造，交换指针。T&& 右值引用，传入右值，直接移动语义，把指针指向swap，把移动构造的参数指向空。转化为右值，f(T&& a):_ptr(a.ptr){a.ptr = nullptr;}





总结：

- 通过移动语义来避免无谓拷贝的问题。
- 通过move语义来将临时生成的左值中的资源无代价的转移到另一个变量中。
- 通过forward来解决不能按照参数实际类型来转发的问题。





### 



## STL

### vector与数组的对比

两者都是存储同类元素，在内存中都是连续结构。

|      | 数组                                       | vector                                   |
| ---- | ------------------------------------------ | ---------------------------------------- |
| 定义 | C和C++中的数据结构                         | C++中的容器，本质是一个类                |
| 内存 | 使用前要实例化，长度就固定了，是栈空间内容 | 实例化时不会固定长度，是堆中动态内存分配 |



### vector、list和queue的对比

见stl内容。

### function object，函数对象的作用和目的？





# 函数



## 内部函数和外部函数

内部函数：static修饰，表示只在文件内可调用

外部函数：extern修饰，表示可在文件外调用。默认函数为外部函数。

## 函数重载



## 内联函数（调用时直接插入代码）

### 定义和作用

问题由来：当程序执行函数调用时，系统要建立栈空间、保护现场、传递参数以及控制程序执行的转移等，这些需要一定的时间和空间。

为提高效率，一个解决办法就是不使用函数，直接将函数的代码嵌入到程序中。但会导致两个缺点：一是相同代码重复书写，二是可读性不好。

所以有了内联函数，inline修饰。

作用原理：可以像普通函数一样被调用，但是调用时并不通过函数调用机制，而是通过将函数体直接插入调用处来实现的（像宏一样展开，取消了函数的参数压栈）。从而大大减少了函数调用带来的开销。

### 内联函数优缺点

优点：

- 使用时直接插入代码、替换展开，非函数调用机制，节省了开销。
- 本身也是一个函数，编译器调用时，会检查参数类型，保证调用正确。因此消除了隐患和局限性（对比宏定义）。
- 可作为类的成员函数，与类的其他普通成员函数相同，可以访问类的私有成员和保护成员，所以主要应用于类。

缺点：

- 有局限性，一般函数体不能太大，否则编译器会放弃内联方式，转为普通函数调用。
- inline对编译器来说只是一种建议，编译器不一定会选择内联方式。

内联函数使用注意事项：

- 函数体内不能包括复杂的控制语句，比如循环语句、switch语句。
- 只将规模小（一般5个语句以下）、使用频繁的函数声明为内联函数。

### 内联函数与宏定义的区别

宏：由预处理器对宏进行展开替换。

内联函数：通过编译器来插入展开。

内联函数优于宏的地方：

- 两者效率一样，但是内联函数优于宏。因为内联函数遵循的类型和作用域规则，使之与一般函数相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，方便。
- 宏在使用时只是简单的文本替换，并没有严格的参数检查。另外它的返回值也不能被强制转换为可转换的合适的类型，所以使用存在隐患和局限性。
- inline的提出就是为了替代宏定义，因为取消了宏的缺点，又很好的继承了宏的优点。







# class



## 访问权限/修饰符

tips：

（1）一个class可以有多个public、private和protected标记区域。

（2）默认访问修饰符是private（即在类内，如果不指定访问修饰符，则默认权限为private）。



- public：公有，公有成员在class外部可访问，可以不使用任何成员函数来设置和获取公有变量的值。
- protected：被保护的成员，该成员只能被该类的成员函数或派生类的成员函数访问。
- private

注意：当





const修饰常量成员：

- 只能用参数初始化列表来初始化，而不能用赋值的方式。因为赋值的方式是两步。





友元：

- 作用：提供了普通函数与一个类成员函数，或者不同类的成员函数之间进行数据共享的机制。



# 继承与派生

## 概述

### 基本概念

继承：如果类B继承于类A，则B就拥有A的成员变量和成员函数。

基类/父类：被继承的类，类A。

派生类/子类：继承的类，类B。



### 继承类别

- 公有继承

- 私有继承

- 保护继承

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |



### 构造函数继承关系

调用构造函数顺序：基类→派生类。

练习：构造函数中增加输出，测试调用顺序。

### 析构函数继承关系

调用析构函数顺序：派生类→派生类子对象→基类。

练习：析构函数中增加输出，测试调用顺序。



## 构造与析构



### 赋值和移动构造对比

- operator = (const T& t)：拷贝赋值

- operator = (T&& t)：移动赋值，可用std::swap实现

#### 赋值构造与移动构造

原先：

c++11前没有右值引用，没有移动语义。赋值等于做了一次赋值，开销较大，过程如下：

- string a = "abc"；string b = "cde"；
- a = b的赋值过程，首先a中的abc释放掉，然后重新申请一段b.size()长度的内存空间，再把b字符串一个一个拷过来。



优化方法一：swap（交换）

swap(a, b)：做的是a的 char *成员和b的 char *成员指针交换一下，再把整个的length交换一下，效率比释放、重新申请内存、拷贝快很多。

优点：能够实现拷贝构造，但避免了赋值的过程。



优化方法二：move（移动）

将一个左值强制转换为右值引用，继而可以通过右值引用使用该值。



## new和delete





## 左值、右值、左值引用、右值引用

### 左值和右值

左值：是可以放在赋值符号左边、可以被赋值的值；左值必须要在内存中有实体；表达式运行结束后依然存在的持久对象；

右值：在赋值符号右边、可取出值付给其他变量的值；表达式结束后就不存在的临时对象。

一个对象被当做右值时，使用的是它的值；被当做左值时，使用的是它的地址。

### 引用

引用的本质是靠指针实现的，相当于变量的别名。

引用可以改变指针的指向，还可以改变指针所指向的值。

引用规则：

- 声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象。即引用必须初始化，不能对引用重定义。
- 对引用的一切操作，相当于对原对象的操作。



### 左值引用和右值引用

左值引用：

type &引用名 = 左值表达式。（一个&）

右值引用：

type &&引用名 = 右值表达式。（两个&，且两个&之间不可有空格）



```c++
int a = 5;
int& b = a;//左值引用
int&& c = a;//虽然看起来像是右值引用，但是有变量c，所以本质上还是左值引用。(这叫已命名的右值引用，编译器会认为是个左值)

//引用主要用来给函数传参
//const是万能绑定
class A;
A(const class& a);//拷贝构造时要用const，因为这样是万能绑定，既能绑定左值，也能绑定右值。
```



### 引用转换（move和forward）

forward：完美转换，继续传递之前的引用类型

move：转换成右值

move constructor移动构造：主要作用是相对于拷贝构造少了内存分配和初始化两个过程，提高了效率。



## 基类与派生类的转化



## 空基类优化

- 单一继承时，可优化为1个字节。多层继承时，不会优化。
- 只要定义了成员属性，就不会优化了。





stl库：用到private继承，vector继承allocator，两个不相干的类，用继承的方式组合起来，从而空基类优化，节省空间。



### 练习





# 多态



分类：

- 静态关联（早期关联），binding：在编译阶段，编译器将同一函数名的不同重载函数进行关联。
- 动态关联（晚期关联），binding：在运行阶段做关联。通过指针变量做关联。



## 重载

### 函数重载





### 运算符重载





运算符函数重载：

- 重载为类的成员函数
- 重载为友元函数

适用场景：

（在多数情况下，将运算符重载为类的成员函数和友元函数都是可以的）。

|      | 类的成员函数                                                 | 友元函数                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|      | 单目运算符最好重载为类的成员函数                             | 大部分双目运算符。                                           |
|      |                                                              | =、（）、[]、->等双目运算符不能重载为友元函数。              |
|      | 类型转换函数只能定义为类成员函数                             | 若运算符所需的操作数希望有隐式类型转换，只能选友元函数       |
|      | 若一个运算符的操作需要修改对象的状态                         |                                                              |
|      | 当运算符是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用） | 如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现 |
|      |                                                              | 当需要重载运算符具有可交换性时，选择重载为友元函数           |



### 练习

- fraction类的各种运算符重载函数（√）
- string类的各种运算符重载函数

- cin、cout、endl也是运算符重载，实现



## 虚函数

作用：

- 关键字：继承，成员函数多种定义，动态多态性。

- 基于类的继承。在派生类继承基类过程中，继承了成员函数。但有时派生类需要成员函数实现不同的功能，而单纯的继承无法实现，也会出现同名函数的覆盖。
- 基类中定义虚函数，从而使不同派生类都可以使用该成员函数，定义不同的功能和接口，以实现不同的功能。
- 实现的动态多态性：同一类族中的不同类对象，对同一函数调用作出不同的响应。





虚函数表及指针

虚函数表指针：通过此指针调用不同类对象的虚函数。三步法：

- Base *p；定义指向基类的指针变量。
- Derive x1;   p = &x1；指针变量指向具体的类对象。
- p->func()；通过指针直接访问所指向的类对象的虚函数。

虚函数表指针使用：练习



虚析构函数

作用：

- 用指针变量p指向new创建的类对象时，Base *p = new  Circle。
- 当用delete释放Circle内存空间时，只会调用父类的析构函数，而不会调用子类的析构函数，会造成内存泄露。
- 因此需要在基类中声明为虚析构函数。





# 输入与输出

## 头文件与流对象







## 标准输入与输出

cin、cout、endl定义或本质：都是iostream类的方法。

流的输入和输出的过程/原理：输入输出设备，缓存，读取和写入，缓存flush







## 标准格式输出流

带具体的格式要求的，比如输出数字宽度width，小数位数，精度，科学技术格式，十进制/八进制/十六进制等



### 格式控制符









### 格式控制函数



## 行输入

cin.get()



cin.getline()



cin.read()



## put()输出函数

输出一个字符



## printf()



# 文件操作





















# 模板

tips

- 宏和模板的区别：

  宏：预处理阶段。

  模板：代码生成是在编译阶段。



## 基本概念

作用：

- 是创建类和函数的蓝图或公式。

- 把功能相似、仅数据类型不同的函数或类设计为通用的函数模板或类模板，提供给用户。



定义和形式

基本语法：template <模板参数列表>

模板形参列表：两个关键词意义相同，可互换或同时使用。

- typename：
- class：旧的程序更有可能只用关键字class。



模板形参类别：

- 模板类型参数：关键字class或typename+说明符。

  template < class T >，T就是一个类型形参，表示一个未知的类型。

- 模板非类型参数：代表一个常量表达式。是内置类型形参。比如template < class T, int a >，int a就是非类型参数。

  - 非类型形参在模板的内部应是常量。
  - 模板的非类型形参只能是：int，指针和引用。string，double等不允许；而double&、double*等是允许的。
  - 调用非类型模板形参的实参必须是一个常量表达式，即必须能在编译时计算出结果。
  - 任何局部对象、局部变量、局部对象和变量的地址、全局对象、全局变量、全局指针类型都不是常量表达式，因此不能用作非类型形参的实参。
  - 全局对象的地址或引用const类型变量是常量表达式，可以用作非类型形参的实参。
  - sizeof表达式的结果是一个常量表达式，可以用作非类型形参的实参。
  - 当模板的形参是整型时，调用该模板时的实参必须是整型的，且在编译期间是常量。
  - Question：swap函数时，当swap（int a, 999）时，引用情况是咋样的？



## 函数模板

### 函数模板基础

问题的引出：

- swap函数交换两个变量的值：变量类型是int，double，char等各种类型时，就需要每一种类型都写一个函数。所以要用template。



一般形式/语法

```c++
template<typename T>//关键字 + 类型
T Func(T a, T b){//与普通函数格式相同，只不过返回值和形参类型可用T类型
	return a + b;
}
```



### 函数模板的特化



问题的引出：比较两个变量的函数，只支持int，double，char类型，不支持字符串类型。所以要定义一个特化版本的模板，以支持字符串的比较。

```c++
//（1）函数模板的一般版本
template<typename T>
int comp(const T& a, const T& b) {
	return (a - b);
}

//（2）特化版本：支持字符串比较
//特化版本1：
template<>//特化的标志，就是<>内没有类型
int comp<const char*>(const char* a, const char* b) {
    return strcmp(a, b);
}
//特化版本2：
template<>
int comp(const char* a, const char* b) {
    return strcmp(a, b);
}

```





## 类模板

### 类模板基础



- 一般形式/语法

```c++
template<class T>
class MyClass{
public:
	MyClass(T x, T y):_x(x), _y(y){}//构造函数
	void func(){
		
	}
private:
	T _x;//类模板的关键是里面的成员属性的类型可选用T类型的，从而实现多次复用。
	T _y;
};


//实例化
MyClass<int> myclass1(3, 6);//注意类后加<int>等明确实例类型。
```



- 成员函数在类外定义时，不同于通常的类外成员函数，应遵照以下格式：

```c++
template<class T>
T MyClass<T>::func(){
	
}
```



### 类模板的特化



进行类模板的特化时，需要特化所有的成员变量和成员函数。

```c++
//比较两个变量是否相等的类。特化版本用于比较字符串是否相等。
//（1）类模板的一般版本
template<class T>
class Cmp{
public:
	bool func(T a, T b) {
		return a == b;
	}
};

//（2）类模板的特化版本
template<>
class Cmp<char *>{
public:
    bool func(char* a, char* b) {
        return strcmp(a, b) == 0;
    }
};

```



### 类模板的偏特化/部分特化

是指根据类模板的某些，但不是全部的参数进行特化，因此又称为部分特化。



```c++
template<class T1, class T2>
class A{

};

//对T2进行了特化
template<class T1>//template后的尖括号内必须列出未特化的模板参数。
class A<T1, int>{//类A后面要列出全部模板参数。
	
};
```



tips：

特化和偏特化：

- 必须有一个主模板
- 模板类型被部分明确化



T&&参数的意义：

- 一般两个&&表示右值的含义，但是在模板中含义不一样，表示引用折叠。
- T&& t：当t为左值时（比如t = 123，是int类型），两个&符号会类型坍塌/引用折叠，变为一个&的作用，所以t的类型即为int&类型。



auto关键字：（c++14版本及以后支持）

- 类型推导：当类型为复杂自定义类型时，返回值是什么类型无法写，只能用auto做类型推导。
- 接收类型无法确定的表达式或函数等



decltype关键字：（c++11中支持）

- decltype（a + b）：就是用来自动求a+b的类型。





模板函数和模板类为什么要写在头文件中？

成员模板函数能否为虚函数？

- 模板的展开是在编译阶段
- 编译时要依赖头文件
- 如果编译时没展开模板，那cpp文件编译时无法确定怎么展开模板。









## constexpr

条件编译：宏



几种方法：

- 条件编译，constexpr
- dynamic_cast
- 



## 元编程

为什么要元编程？在编译阶段就处理掉了

练习：

- 大于60分输出good，小于60份输出bad
- 判断奇偶数
- 判断素数



### traits

类型萃取/类型推导，type_traits，判断一个类型是什么

头文件：





#### traits的实现过程

- 元编程的元数据
- 模板的偏特化



#### stl中的traits

判断是否为某种类型：is_pointer，is_function，



## shared_ptr





## Question

- 类模板什么时候会被实例化呢？
  - 





- 关键字typename和class有什么区别
  - 不同点：class原本用于定义类。
  - 相同点：c++引入模板的概念后，最初定义模板的方法是：template < class T >，此处的class关键字表明T是一个类型。后为避免class含义混淆，才引入了typename关键字。因此typename是专门用于模板的定义的。只要用于模板中时，class和typename含义相同。
- 类模板和模板类的区分？
  - 类模板：本质是个模板，是允许用户为类定义一种模式，当类中的某些成员属性、成员方法、成员方法返回值，能够去任意类型（包括系统内置的和用户自定义的）。
  - 模板类：本质是个类，是当一个类中的成员属性、成员函数的参数、成员函数返回值等不能确定是何种类型时，就必须将此类声明为模板，它代表的不是一个具体的、实际的类，而是代表一类的类。
  - 是否可以说，将类声明为模板后，就变成了类模板？











# 异常处理

程序执行期间遇到不正常情况时，允许两个独立开发的程序组件相互通信的机制。



## 常见错误

三类错误：



- 语法错误：

常见的变量未定义、少括号、少分号等。特点是容易发现。

由编译器检查发现。



- 逻辑错误

编译可以通过，主要因为设计者原因，导致无法得到预计的结果。



- 运行时错误

运行期间发生的错误，一般与算法、逻辑有关。比如打开文件失败、数组下标溢出、系统内存不足等。

异常（exception）机制：在程序出现异常时，在终止程序前，告诉用户发生了什么。





# 设计模式



## bind





# 游戏框架



